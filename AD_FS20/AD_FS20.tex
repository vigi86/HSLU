\documentclass[10pt,a4paper]{article}
\usepackage{ngerman}
\usepackage[utf8]{inputenc}
\usepackage{sectsty}
\usepackage[table]{xcolor}
\usepackage{lastpage}
\usepackage{amssymb, enumitem, fancyhdr, graphicx, float, makeidx, textcomp, multicol}
\usepackage[hidelinks]{hyperref}
\usepackage[hang,flushmargin]{footmisc}
\usepackage{listings}
\lstloadlanguages{SQL, Java}
\definecolor{pblue}{rgb}{0.13,0.13,1}
\definecolor{pgreen}{rgb}{0,0.5,0}
\definecolor{pred}{rgb}{0.9,0,0}
\definecolor{pgrey}{rgb}{0.46,0.45,0.48}
\definecolor{background}{rgb}{0.95,0.95,0.92}
\lstset{language=Java,
  backgroundcolor=\color{background},
  frame=single,
  rulecolor=\color{pgrey},
  showspaces=false,
  showtabs=false,
  breaklines=true,
  showstringspaces=false,
  breakatwhitespace=true,
  commentstyle=\color{pgreen},
  keywordstyle=\color{pblue},
  stringstyle=\color{pred},
  breaklines=true,
  numbers=left,
  numberstyle=\tiny\color{pgrey},
  basicstyle=\ttfamily\footnotesize,
  inputencoding=utf8,
  extendedchars=true,
  literate={ä}{{\"a}}1 {ö}{{\"o}}1 {ü}{{\"u}}1,
  moredelim=[il][\textcolor{pgrey}]{\$\$},
  moredelim=[is][\textcolor{pgrey}]{\%\%}{\%\%}
}

\makeindex

\definecolor{dunkelblau}{rgb}{0,0.4,0.6}
\subsectionfont{\color{dunkelblau}}

\title{AD FS 2020}
\author{Victor Fernández}
\date{Januar 2020}

\addtolength{\oddsidemargin}{-.875in}
\addtolength{\evensidemargin}{-.875in}
\addtolength{\textwidth}{1.75in}
\addtolength{\topmargin}{-.875in}
\addtolength{\textheight}{1.75in}

% muss nach Änderung der margin kommen!
\pagestyle{fancy}
\fancyhf{} %reset
\fancyhead[L]{HSLU}
\fancyhead[C]{AD}
\fancyhead[R]{\thepage/\pageref{LastPage}}
\fancyfoot[L]{}
\fancyfoot[C]{}
\fancyfoot[R]{}
\renewcommand{\headrulewidth}{0.2pt} % Strich in Kopfzeile

\begin{document}

\maketitle
\tableofcontents
\thispagestyle{empty}
\pagebreak
\part{SW 01 - Einführung Algorithmen, Datenstrukturen \& Komplexität}
\section{Lernziele}
Sie \dots
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item können beschreiben, was ein Algorithmus ist
    \item können erläutern, was gleichwertige Algorithmen sind
    \item können erläutern, weshalb Algorithmen und Datenstrukturen eng zusammenhängen
    \item können beschreiben, was Komplexität bei einem Algorithmus meint
    \item können für einfache Funktionen deren Ordnung bestimmen
    \item können für einfache Code-Fragmente deren Zeitkomplexität bestimmen
    \item kennen die wichtigsten Ordnungsfunktionen im Vergleich
    \item kennen wichtige Aspekte bei der Interpretation einer Ordnung
    \item wissen, welche Ordnungen praktisch versagen!
\end{itemize}

\section{Algorithmen}
\subsection{Definition Algorithmus}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Ein Algorithmus ist ein \textbf{präzise festgelegtes Verfahren zur Lösung eines Problems}; genauer gesagt, zur Lösung einer Problem\textbf{klasse} (beinhaltend gleichartige Probleme, häufig unendlich viele).
    \item Algorithmus=Lösungsverfahren (Rezept, Anleitung)
    \item Probleme bzw. Problemklassen, die mit Algorithmen gelöst werden können, heissen \textbf{$\Rightarrow$ berechenbar}
\end{itemize}

\subsection{Beispiele}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Berechnung des \textbf{ggT} für zwei natürliche Zahlen (Euklidischer Algorithmus)
    \item Zeichnen der \textbf{Verbindungslinie}, welche zwei Punkte verbindet (Bresenham Algorithmus)
    \item \textbf{Sortierung} von zufällig vorliegenden ganzen Zahlen (Mergesort Algorithmus)
    \item Finden des \textbf{kürzesten Wege}s zwischen zwei Knoten in einem zusammenhängenden Graphen (Algorithmus von Dijkstra)
    \item Entscheiden, ob es sich bei einer vorliegenden natürlichen Zahl um eine \textbf{Primzahl} handelt (Algorithmus "`Sieb von Aktin"')
    \item Berechnung des \textbf{Integrals} bei vorliegenden Funktionswerten in einem bestimmten Bereich (Runge-Kutta Algorithmus)
    \item Finden einer \textbf{Lösung} in einem vorgegebenen Lösungsraum (Backtracking Algorithmus)
\end{itemize}

\subsection{Eigenschaften eines Algorithmus}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item schrittweises Verfahren
    \item ausführbare Schritte
    \item eindeutiger nächster Schritt (\textbf{determiniert})
    \item endet nach endlich vielen Schritten (\textbf{terminiert})
\end{itemize}

\subsection{Algorithmen vs. Informatik}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Der Computer:
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item arbeitet schrittweise
        \item Anweisung für Anweisung (jede Anweisung korrespondiert mit einem ausführbaren Befehl)
        \item arbeitet präzise und schnell
    \end{itemize}
    \item Algorithmen sind zentrales Thema in der Informatik und in der Mathematik
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item \textbf{Algorithmentheorie}: Guter Lösungsalgorithmus für bestimmte Problemstellung?
        \item \textbf{Komplexitätstheorie}: Ressourcenverbrauch von Rechenzeit und Speicherbedarf?
        \item \textbf{Berechenbarkeitstheorie}: Was ist mit einer Maschine grundsätzlich lösbar und was nicht?
    \end{itemize}
\end{itemize}

\subsection{Algorithmen und Datenstrukturen}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item \textbf{Algorithmen operieren auf Datenstrukturen} und \textbf{Datenstrukturen bedingen spezifische Algorithmen}. Beides ist eng miteinander verbunden.
    \item Bei vielen Algorithmen hängt der \textbf{Ressourcenbedarf}, d.h. die benötigte Laufzeit und der Speicherbedarf, bon der Verwendung geeigneter Datenstrukturen ab.
\end{itemize}

\subsection{Beispiel Euklidischer Algorithmus}
\subsubsection{Manuelle Ausführung}
ggT von 8 und 14:\\
\begin{tabular}{|c|c|c|c|}
    \hline
        Schritt&A&B&A-B\\
        \hline
        1&14&8&6\\
        2&8&6&2\\
        3&6&2&4\\
        4&4&2&\cellcolor{background}2\\
        5&2&2&0=ggT $\uparrow$ 2\\
    \hline
\end{tabular}

\subsubsection{Iterative Implementation}
Beispielcode (1):\\
\lstset{language=Java}
\begin{lstlisting}
public static int ggtIterativ(int a, int b) {
    while (a != b) {
        if (a > b) {
            a = a - b;
        } else {
            b = b - a;
        }
    }
    return a;
}
\end{lstlisting}

\subsubsection{Iterative Implementation}
Beispielcode (2):\\
\lstset{language=Java}
\begin{lstlisting}
public static int ggtIterativ(int a, int b) {
    while ((a != 0) && (b != 0)) {
        if (a > b) {
            a = a % b;
        } else {
            b = b % a;
        }
    }
    return (a + b); // a oder b ist 0
}
\end{lstlisting}

\subsubsection{Rekursive Implementation}
\lstset{language=Java}
\begin{lstlisting}
public static int ggtRekursiv(final int a, final int b) {
    if (a > b) {
        return ggtRekursiv(a - b, b);
    } else {
        if (a < b) {
            return ggtRekursiv(a, b -a);
        } else {
            return a;
        }
    }
}
\end{lstlisting}

\section{Datenstrukturen}
\subsection{Definition Datenstruktur}
Eine Datenstruktur ist ein \textbf{Konzept zur Speicherung und Organisation von Daten}. Es handelt sich um eine \textbf{Struktur}, weil die Daten in einer bestimmten Art und Weise angeordnet und verknüpft werden, um den Zugriff auf sie und ihre Verwaltung möglichst effizient zu ermöglichen.\\
Datenstrukturen sind daher insbesondere auch durch die \textbf{Operationen} charakterisiert, welche Zugriff und Verwaltung realisieren.
\subsection{Beispiele}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item \textbf{Array}: direkter Zugriff (+), fixe Grösse (-)
    \item \textbf{Liste}: flexible Grösse (+), sequentieller Zugriff (-)
\end{itemize}

\section{Komplexität}
\subsection{Definition Komplexität}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Komplexität (auch Aufwand oder Kosten) eines Algorithmus
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item \textbf{Ressourcenbedarf = f (Eingabedaten)}
    \end{itemize}
    \subitem D.h. "`Wie hängt der Ressourcenbedarf von den Eingabedaten ab?"'
    \item Ressourcenbedarf
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Rechenzeit: \textbf{Zeitkomplexität}
        \item Speicherbedarf: \textbf{Speicherkomplexität}
    \end{itemize}
    \item Eingabedaten
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Grösse der Daten\textbf{menge} (z.B. 10 vs. 1'000'000'000 zu sortierende Elemente)
        \item Grösse eines Daten\textbf{wertes} (z.B. 10! vs. 1'000'000'000!)
    \end{itemize}
\end{itemize}

\subsection*{Was interessiert uns?}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item \textbf{Wie wächst der Ressourcenbedarf}, wenn eine grössere Datenmenge bzw. grössere Datenwerte zu verarbeiten sind? Z.B.
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Verdoppelt oder vervierfacht sich der Ressourcenbedarf für das Sortieren der doppelten Datenmenge?
        \item Bleibt der Ressourcenbedarf gleich, wenn wir den ggT von zwei sehr grossen Zahlenwerten berechnen wollen?
    \end{itemize}
    \item Es interessiert an dieser Stelle \textbf{NICHT} der exakte/absolute Ressourcenbedarf! Z.B.
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Die ggT-Berechnung von 1'000'000'489 und 9'123'000'124 auf dem Computer XY mit der Konfiguration Z dauert 420ms.
        \item Entsprechende Rechenzeiten sind für jeden Computer anders. Möchte man die Rechenzeit reduzieren, so lässt sich jederzeit ein schnellerer Computer kaufen!
    \end{itemize}
\end{itemize}

\subsubsection{Zeitkomplexität Implementation}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Annahmen:
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Die Methoden \texttt{task1()}, \texttt{task2()} und \texttt{task3()} besitzen in etwa dieselben Rechenzeiten
        \item Die Schleifensteuerungen beanspruchen im Vergleich vernachlässigbare kleine Ausführungszeiten
    \end{itemize}
\end{itemize}

\lstset{language=Java}
\begin{lstlisting}[mathescape]
public static void task(final int n) {
    task1(); task1(); task1(); task1();     // T $\sim$ 4
    for (int i = 0; i < n; i++) {           // äussere Schleife: n-mal
        task2(); task2(); task2();          // T $\sim$ n $\cdot{}$ 3
        for (int j = 0; j < n; j++) {       // innere Schleife: n-mal
            task3(); task3();               // T $\sim$ n $\cdot{}$ n $\cdot{}$ 2
        }
    }
}
\end{lstlisting}
$\rightarrow$ Rechenzeit T von \texttt{task(n)}: $T=f(n)\sim 4+3\cdot n+2n^2$

\subsubsection{Zeitkomplexität für grosse n}
\paragraph{TODO Tabelle Zeitkomplexität}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Für grosse n dominiert der Anteil von \textbf{$n^2$}
    \item Für grosse n verlaufen die Funktionen parallel, d.h. unterscheiden sich nur durch einen konstanten Faktor (vgl. logarith. Massstäbe!)
    \item Wir sagen:
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item f(n) ist von der \textbf{Ordnung $O(n^2)$} bzw. die
        \item Rechenzeit von \texttt{task(n)} verhält sich gemäss \textbf{Ordnung $O(n^2)$}
    \end{itemize}
\end{itemize}
\paragraph{TODO Big-O \& Ordnungsfunktionen}

\part{Rekursion}
\section{Lernziele}
Sie \dots
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item können beschreiben, was Algorithmen und Datenstrukturen mit Selbstähnlichkeit und Selbstbezug zu tun haben
    \item können bei einer rekursiven Methode Rekursionsbasis und Rekursionsvorschrift identifizieren
    \item können gut nachvollziehbar aufzeichnen, wie eine rekursive Methode abgearbeitet wird
    \item können beschreiben, wozu "`Heap"' und "`Call Stack"' dienen
    \item können die Eigenheiten der Rekursion (vs. Iteration) beschreiben
    \item können einfache rekursive Methoden implementieren
\end{itemize}

\section{Iteration vs. Rekursion}
\subsection{Iterative Fakultätsberechnung}
\subsection{Rekursive Fakultätsberechnung}
\section{Call Stack}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Für die Ausführung eines Programmes verwendet die Java Virtual Machine (JVM) zwei wichtige Speicher: \textbf{Heap} und \textbf{Call Stack}
    \item \textbf{Heap}: In diesem Speicherbereich werden die Objekte gespeichert, d.h. deren Instanzvariablen bzw. Zustände. Nicht mehr referenzierbare Objekte werden durch den Garbage Collector (GC) automatisch gelöscht.
    \item \textbf{Call Stack}: Letztendlich wid bei der Ausführung eines Java-Programmes eine Kette von Methoden aufgerufen, bzw. abgearbeitet. Ursprung ist die \texttt{main()}-Methode. Jeder Methodenaufruf bedingt gewissen Speicher, insbesondere für die aktuellen Parameter und lokalen Variablen. Dazu dient der Call Stack. Ein neuer Methodenaufruf bewirkt, dass der Call Stack wächst, bzw. darauf ein zusätzlicher \textbf{Stack Frame} angelegt wird.
\end{itemize}
\paragraph{TODO Bild Call Stack}7

\subsection{Mächtigkeit der Rekursion}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Rekursion und Iteration sind praktisch \textbf{gleich mächtig}
    \item D.h. die Menge der berechenbaren Problemstellungen bei Verwendung der Rekursion und Verwendung der Iteration ist gleich
    \item D.h. eine rekursive Implementation lässt sich grundsätzlich immer in eine gleichwertige iterative Implementation umprogrammieren und umgekehrt
\end{itemize}
Hinweis: Dies gilt exakt nur für sogenannte primitiv-rekursive Probleme, d.h. bei linearer und nicht geschachtelter Rekursion bzw. bei reinen Zählschleifen.


\part{SW 02 - Datenstrukturen}
\section{Lernziele}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Sie kennen Eigenschaften von Datenstrukturen
    \item Sie können die Komplexität von Operationen auf unterschiedlichen Datenstrukturen beurteilen
    \item Sie kennen den Aufbau, die Eigenschaften und die Funktionsweise ausgewählter Datenstrukturen
    \item Sie können Datenstrukturen exemplarisch selbst implementieren
    \item Sie können abhängig von Anforderungen die geeigneten Implementationen von Datenstrukturen auswählen
\end{itemize}

\subsection{Eigenschaften von Datenstrukturen}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item In welcher Reihenfolge oder Sortierung werden die Elemente Abgelegt
    \item Welche Operationen werden zur Verfügung gestellt
    \item Ist die Datenstruktur dynamisch oder statisch (Grösse)
    \item Bestehen zwischen den Elementen explizite oder implizite Beziehungen
    \item Besteht direkter oder nur indirekter/sequenzieller Zugriff auf die einzelnen Datenelemente
    \item Wie gross ist der Aufwand für die einzelnen Operationen, speziell in Abhängigkeit zur Datenmenge
\end{itemize}

\subsection{Reihenfolge uns Sortierung}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Datenstrukturen als reine Sammlung: Die einzelnen Datenelemente sind darin ungeordnet abgelegt und die Reihenfolge ist nicht deterministisch
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Analogie: Steinhaufen
    \end{itemize}
    \item Datenstrukturen welche die Datenelemente in einer bestimmten Reihenfolge (z.B. in der Folge des Einfügens) enthalten und diese implizit beibehalten
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Analogie: Stapel von Büchern
    \end{itemize}
    \item Datenstrukturen welche die Elemente (typisch beim Einfügen) implizit sortieren / ordnen
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Analogie: Vollautomatisches Hochregal
    \end{itemize}
    \item Auch abhängig von der Implementation bzw. Nutzung
\end{itemize}

\subsection{Operation auf Datenstrukturen}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Es gibt einige elementare Methoden die auf Datenstrukturen angewendet werden können
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Einfügen von Elementen
        \item Suchen von Elementen
        \item Entfernen von Elementen
        \item Ersetzen von Elementen
    \end{itemize}
in Datenstrukturen
    \item Operation in Abhängigkeit einer (optionalen) Reihenfolge oder Sortierung (natürlich oder speziell)
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Nachfolger: Nachfolgendes Datenelement
        \item Vorgänger: Vorangehendes Datenelement
        \item Sortierung: Sortieren der Datenelemente nach Attributwerten
        \item Maxima und Minima: kleinstes und grösstes Datenelement
    \end{itemize}
\end{itemize}

\subsection{Statische vs. dynamische Datenstruktur}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Eine \textbf{statische} Datenstruktur hat nach ihrer Initialisierung eien feste, unveränderliche Grösse. Sie kann somit nur eine beschränkte Anzahl Elemente aufnehmen.
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Analogie: Getränkeflasche
        \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
            \item Grösse der Flasche ist gegeben, ebenso maximaler Inhalt
            \item Die Flasche selber nimmt immer denselben Platz ein
        \end{itemize}
    \end{itemize}
    \item Eine \textbf{dynamische} Datenstruktur hingegen kann ihre Grösse während der Lebensdauer verändern. Sie kann somit eine beliebige\footnote{natürlich begrenzt durch den verfügbaren Speicher} Anzahl Elemente aufnehmen
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Analogie: Luftballon
        \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
            \item Je nach Gasvolumen deht sich der Luftballon räumlich aus oder zieht sich wieder zusammen
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection{Explizite vs. implizite Beziehungen}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Bei \textbf{expliziten} Datenstrukturen werden die Beziehungen zwischen den Daten von jedem Element \textbf{selber explizit} mit Referenzen festgehalten
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Analogie: Fahrradkette
        \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
            \item Kettenglieder sind explizit miteinander verknüpft
            \item jedes Kettenglied kennt seine Nachbarglieder
        \end{itemize}
    \end{itemize}
    \item Bei \textbf{impliziten} Datenstrukturen werden die Beziehungen zwischen den Daten \textbf{nicht} von den Elementen selber festgehalten
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Die Beziehungen werden quasi von \textsl{aussen} definiert, z.B. über eine externe Nummerierung (Index)
        \item Analogie: Buchregal mit Büchern
        \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
            \item Bücher stehen einfach (ggf. auch geordnet) nebeneinander
            \item das einzelne Buch weiss nicht wo es steht, bzw. hingehört
        \end{itemize}
    \end{itemize}
\end{itemize}

\subsection{Aufwand von Operationen}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Der \textbf{Aufwand} (Rechnen- und Speicherkomplexität) variiert sowohl für die verschiedenen Operationen als auch (oft) in Abhängigkeit der enthaltenen Datenmenge in einer Datenstruktur
    \item Meistens interessiert uns \textsl{nur} die Ordnung, also wie sich der Aufwand in Abhängigkeit zur Anzahl der Elemente verhält
    \item Beispiele:
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Buch auf einen Stapel legen (ungeordnet):\\ \textbf{$\mathcal{O}(1)\rightarrow$}Konstant
        \item Buch in der Bibliothek alphabetisch einordnen:\\ im schlechtesten Fall \textbf{$\mathcal{O}(n)\rightarrow$}Linear
        \item Eine unsortierte Menge von Büchern alphabetisch ordnen:\\ im schlechtesten Fall \textbf{$\mathcal{O}(n^2)\rightarrow$}Quadratisch (Polynomial)
    \end{itemize}
\end{itemize}

\section{Arrays}
\subsection{Eigenschaften}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item \textbf{Statische} Datenstruktur
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Grösse wird bei Initialisierung festgelegt. Beispiel:
        \begin{lstlisting}
char[] demo = new char[10];
        \end{lstlisting}
    \end{itemize}
    \item \textbf{Implizite} Datenstruktur
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Die einzelnen Elemente haben keine Beziehung untereinander bzw. keine Referenzen aufeinander
    \end{itemize}
    \item \textbf{Direkter} Zugriff
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Auf jedes Element kann über den Index direkt zugegriffen werden
    \end{itemize}
    \item \textbf{Reihenfolge} der Elemente
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Der Array behält die Positionen der Datenelemente, so wie sie zugewiesen / eingeordnet wurden, unverändert bei
    \end{itemize}
\end{itemize}

\part{SW 03 - Bäume}
\section{Lernziele}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Sie wissen wie eine baumartige Datenstruktur aufgebaut ist
    \item Sie kennen verschiedene Beispiele von Baumstrukturen
    \item Sie kennen die Grundelemente eines Baumes:\\
    Wurzel, Knoten, Blatt und Kanten
    \item Sie können die Kenngrössen eines Baumes beschreiben
\end{itemize}

\subsection{Verwendung und Arten von Baumstrukturen}
Zwei grundlegende Szenarien:
\begin{enumerate}[noitemsep,topsep=0pt,leftmargin=*]
    \item Die Daten haben bereits inhärent eine hierarchische Struktur, welche man entsprechend abbilden will. Beispiele:
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Dateisystem mit Verzeichnissen und Dateien
        \item Stammbaum (Genealogie)
        \item Vererbungshierarchie in Java (nur mit Einfachvererbung)
    \end{itemize}
    \item Wenn man in einer geordneten Datenmenge einzelne Elemente sehr schnell finden will $\rightarrow$binärer Suchbaum
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Die Suche über eine Baumstruktur hat typisch nur einen Aufwand von $\mathcal{O}(\log n)$, und ist somit der rein sequenziellen Suche mit \textbf{$\mathcal{O}(n)$} deutlich überlegen
    \end{itemize}
\end{enumerate}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Mit Ausnahme der Wurzel (Ursprung des Baumes, die \textbf{alle} baumartigen Strukturen haben) können Bäume sehr stark variieren:
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Unterschiedliche Anzahl Äste
        \item Unterschiedliche Länge (Tiefe) der Äste
        \item Die Breite (Grad) und die Höhe der Bäume ist sehr variabel
    \end{itemize}
    \item Je nach Anwendungszweck definiert man mehr oder weniger \textbf{Restriktionen}, welche dann zu spezifischeren Baumstrukturen führen, welche auch spezifischere Eigenschaften aufweisen
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Zweks Beschleunigung und/oder einfacherer Algorithmen
    \end{itemize}
\end{itemize}

\subsection{Gerichtete und ungerichtete Bäume}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Ein ungerichteter Baum ist eine reine Hierarchie
    \item Out-Tree, Navigation von der Wurzel \textbf{nach unten} zu den Blättern
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item $\rightarrow$Kanten (Pfeile) gehen von der Wurzel aus. Am Häufigsten!
    \end{itemize}
    \item In-Tree, Navigation von den Blättern \textbf{nach oben} zur Wurzel
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item $\rightarrow$Kanten (Pfeile) zeigen zur Wurzel hin. Seltener.
    \end{itemize}
    \item Diverse Spezialformen von Bäumen (Beispiele)
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item \textbf{Binär}-Baum - am einfachsten und häufigsten
        \item \textbf{AVL}-Baum - höhenbalancierter Binärbaum
        \item \textbf{B}-Baum - balancierter Baum, \textbf{nicht} zwingend binär!
        \item \textbf{B*}-Baum - restriktivere Form B-Baumes (ebenfalls balanciert)
        \item \textbf{Binomial}-Baum - speziell strukturierter Baum
        \item etc.
    \end{itemize}
\end{itemize}

\subsection{Kenngrössen von Bäumen}
\subsubsection{Ordnung}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Die \textbf{Ordnung} (order) eines Baumes definiert, wie viele Kinder ein Knoten \textbf{maximal} haben darf
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Die Anzahl muss in eine konkreten (Teil-)BAum aber \textbf{nicht} zwingend erreicht werden
    \end{itemize}
    \item Die Ordnung ist eine Definition!
\end{itemize}

\subsubsection{Grad}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Der \textbf{Grad} (degree) eines Knotens sagt, wie viele Kinder ein bestimmter Knoten \textbf{aktuell} tatsächlich hat
    \item Bei einem Baum, z.B. der \textbf{fünften} Ordnung, darf der Grad jedes einzelnen Knotens \textbf{maximal 5} betragen, also maximal fünf Kinder
\end{itemize}

\subsubsection{Pfad}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Als \textbf{Pfad} (path) eines Knotens bezeichnet man den Weg von der Wurzel bis zum entsprechenden Knoten, bzw. Blatt
\end{itemize}

\subsubsection{Tiefe}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Die \textbf{Tiefe} (depth) eines Knotens beschreibt die Länge seines Pfades. Dazu werden die Kanten auf seinem Pfad gezählt
    \item Achtung: Es gibt auch eine Zählweise die bei 1 beginnt; es ist nicht einheitlich geregelt
\end{itemize}

\subsubsection{Niveaus / Ebenen (levels)}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Als \textbf{Niveau} oder \textbf{Ebene} bezeichnet man die Menge aller Knoten, welche die gleiche \textbf{Tiefe} haben
\end{itemize}

\subsubsection{Höhe}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Die \textbf{Höhe} (height) eines Baumes definiert sich aus der \textbf{Tiefe} des Knotens, welcher am \textbf{weitesten} von der Wurzel entfernt ist, bzw. aus der Anzahl der \textbf{Niveaus}
\end{itemize}

\subsubsection{Gewicht}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Das \textbf{Gewicht} (weight) eines Baumes definiert sich über die Anzahl der enthaltenen Knoten
\end{itemize}

\subsection{Füllgrade}
\subsubsection{Ausgefüllt}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Ein Baum wird als \textbf{ausgefüllt} bezeichnet, wenn \textbf{jeder innere Knoten} die \textbf{maximale} Anzahl an Kindern hat
    \item Der \textbf{Grad aller} inneren Knoten ist somit \textbf{gleich} der \textbf{Ordnung} des Baumes
\end{itemize}

\subsubsection{Voll}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Ein Baum wird als \textbf{voll} bezeichnet, wenn das \textbf{letzte} Niveau linksbündig (oder auch rechts) angeordnet ist, und alle \textbf{restlichen} Niveaus die \textbf{maximale} Anzahl an Kindern enthalten
\end{itemize}

\subsubsection{Vollständig oder komplett}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Ein Baum wird als \textbf{vollständig} oder \textbf{komplett} bezeichnet, wenn \textbf{jedes} Niveau die \textbf{maximale} Anzahl Knoten enthält
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Er hat dann für sein \textbf{Gewicht} die \textbf{minimale} Anzahl \textbf{Niveaus}
        \item Die Struktur ist immer \textbf{symmetrisch} und ausgeglichen
    \end{itemize}
\end{itemize}

\section{Binäre Bäume}
\subsection{Lernziele}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Sie sind mit binären Bäumen vertraut
    \item Sie kennen die Algorithmen, um binäre Bäume auf unterschiedliche Arten zu traversieren
    \item Sie sind mit den spezielen Eigenschaften von binären Suchbäumen vertraut
    \item Sie wissen wie das Suche, Einfügen und Entfernen von Knoten in binären Suchbäumen konzeptionell abläuft
    \item Sie verstehen, was ein ausgeglichener Baum ist und wie man diesen Zustand herstellen kann
\end{itemize}

\subsection{Binärer Baum}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Ein \textbf{binärer Baum} (binary tree) ist als Baum mit \textbf{Ordnung 2} definiert. Jeder Knoten hat somit maximal \textbf{zwei} Kinder
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item Diese werden als \textbf{linker und rechter} Kindknoten bezeichnet
    \end{itemize}
    \item Binäre Bäume sind in der Informatik \textbf{sehr} beliebt, weil:
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item durch die Beschränkung auf die \textbf{Ordnung 2} einige Algorithmen stark vereinfacht werden
        \item auf binären Bäumen unterschiedliche Durchlaufordnungen ($\rightarrow$Traversierungen) möglich sind
        \item die Suche in einem binären (Such-)Baum einer binären Suche entspricht
    \end{itemize}
\end{itemize}

\subsection{Traversieren eines binären Baumes}
\begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
    \item Aufgrund der spezifischen Eigenschaft von binären Bäumen (Ordnung 2) kann man diese auf \textbf{drei} unterschiedliche Arten traversieren (vergleiche dazu Iteration bei \textbf{Listen})
    \begin{itemize}[noitemsep,topsep=0pt,leftmargin=*]
        \item \textbf{Preorder} - Hauptreihenfolge
        \item \textbf{Postorder} - Nebenreihenfolge
        \item \textbf{Inorder} - Symmetrische Reihenfolge
    \end{itemize}
    \item Die Algorithmen, welche diese drei verschiedenen Traversierungsarten beschreiben, sind alle \textbf{rekursive} Algorithen
    \item Alle Traversierungen sind direkt abhängig von der Anzahl Knoten und haben somit einen Aufwand von $\mathcal{O}(n)$
\end{itemize}

\subsubsection{Preorder}
\subsubsection{Postorder}
\subsubsection{Inorder}

\subsection{Binäre Suchbäume}
\subsection{Geordneter binärer Suchbaum}
\end{document}